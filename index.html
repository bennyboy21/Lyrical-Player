<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Now Playing Tracker (LRC Lib Sync)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #121212; /* Dark Spotify background */
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .container {
            width: 100%;
            max-width: 420px;
            background: #1e1e1e; /* Card background */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            padding: 1.5rem;
        }
        .spotify-green {
            background-color: #1DB954;
            transition: background-color 0.15s ease;
        }
        .spotify-green:hover {
            background-color: #1ed760;
        }
        .pulse-icon {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.05); }
        }
        /* Style for lyrics */
        .lyrics-box {
            height: 200px; /* Taller box for better lyric visibility */
            overflow-y: auto;
            scroll-behavior: smooth;
            background-color: #282828;
            padding: 1rem;
            border-radius: 0.5rem;
        }
        .lyric-line {
            padding: 0.5rem 0;
            font-size: 1.2rem;
            line-height: 1.6;
            color: #b3b3b3;
            transition: color 0.3s ease, font-weight 0.3s ease, transform 0.3s ease;
        }
        .lyric-line.active {
            color: #ffffff;
            font-weight: 700;
            font-size: 1.35rem; /* Slightly larger when active */
            transform: scale(1.02);
            text-shadow: 0 0 8px rgba(29, 185, 84, 0.7);
        }
    </style>
</head>
<body>

    <div class="container rounded-xl">
        <h1 class="text-3xl font-bold mb-6 text-center text-white flex items-center justify-center">
            <svg class="w-8 h-8 mr-2" fill="#1DB954" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm5.111 17.583c-.156.26-.502.348-.762.193a7.35 7.35 0 0 1-8.524-3.558c-.144-.265-.057-.607.208-.751.265-.144.607-.057.751.208a6.11 6.11 0 0 0 7.103 2.96c.26.155.348.502.193.762zm1.61-3.033c-.167.282-.553.388-.836.222a9.773 9.773 0 0 1-11.232-4.664c-.282-.167-.388-.553-.222-.836.167-.282.553-.388.836-.222a8.553 8.553 0 0 0 9.845 4.103c.282.167.388.553.222.836zm.186-4.636c-1.39-2.327-3.92-3.83-6.666-3.83-2.747 0-5.277 1.503-6.667 3.83-.284.168-.672.062-.84-.223-.167-.285-.062-.672.223-.84C6.556 2.5 9.17 1 12 1s5.444 1.5 6.949 3.84c.285.168.39.555.223.84z"/>
            </svg>
            Spotify Tracker
        </h1>

        <!-- Login Section -->
        <div id="login-section" class="mb-6 text-center">
            <p class="text-gray-300 mb-4">Log in to Spotify to start tracking your current song.</p>
            <button id="login-button" class="spotify-green text-black font-bold py-3 px-6 rounded-full w-full shadow-lg hover:shadow-xl transform hover:scale-[1.02] transition-all duration-300">
                Login with Spotify
            </button>
        </div>

        <!-- Song Status Section -->
        <div id="status-section" class="hidden text-center">
            <div id="status-message" class="text-xl font-semibold mb-4 text-white"></div>
            
            <div id="song-display" class="hidden bg-gray-800 p-4 rounded-lg text-left shadow-inner">
                <img id="album-art" class="w-full h-auto rounded-lg mb-4 shadow-md" alt="Album Art">
                <p class="text-xs text-gray-400 font-medium uppercase tracking-wider">Now Playing</p>
                <h2 id="song-title" class="text-2xl font-bold mt-1 text-white"></h2>
                <p id="artist-name" class="text-lg text-gray-300"></p>
                <p id="album-name" class="text-sm text-gray-400 mt-2"></p>
                <!-- Time Display -->
                <p id="time-text" class="text-sm text-gray-400 text-right font-mono mt-2 mb-1">0:00 / 0:00</p>
                <!-- Progress Bar -->
                <div id="progress-bar-container" class="mt-1 h-1 bg-gray-700 rounded-full overflow-hidden">
                    <div id="progress-bar" class="h-full spotify-green transition-all duration-500" style="width: 0%;"></div>
                </div>

                <!-- Lyrics Container -->
                <div id="lyrics-container" class="mt-6 text-center">
                    <!-- Lyrics will be inserted here -->
                    <div class="lyrics-box" id="lyrics-content">
                        <p class="text-gray-400 italic mb-4 mt-8 text-sm">Loading lyrics...</p>
                    </div>
                </div>
            </div>

            <!-- Polling Indicator -->
            <p id="polling-indicator" class="mt-4 text-sm text-gray-500 hidden">
                <span class="inline-block h-3 w-3 rounded-full spotify-green mr-2 pulse-icon"></span>
                Checking for playback...
            </p>
        </div>
    </div>

    <script>
        // --- IMPORTANT: CONFIGURE THESE VALUES ---
        const CLIENT_ID = '86d5980bc6284ccba0515e63ddd32845'; // Spotify Client ID
        const REDIRECT_URI = 'https://bennyboy21.github.io/Lyrical-Player/'; // Redirect URI
        // NOTE: LRC Lib is used for fetching lyrics. A key is usually not required for simple searches.
        const LRCLIB_API_BASE = 'https://lrclib.net/api/search'; 
        // ------------------------------------------

        const AUTHORIZE_URL = 'https://accounts.spotify.com/authorize';
        const TOKEN_URL = 'https://accounts.spotify.com/api/token';
        const NOW_PLAYING_URL = 'https://api.spotify.com/v1/me/player/currently-playing';
        const SCOPE = 'user-read-currently-playing';

        let accessToken = null;
        let pollingIntervalId = null;
        
        // --- New Variables for Smooth Progress Tracking ---
        let progressUpdaterId = null; 
        let currentTrackId = null;    
        let progressStartTime = 0;    
        let initialProgressMs = 0;    
        let trackDurationMs = 0;      
        let currentLyrics = null;     // Stores the lyrics object for the currently playing song
        let activeLyricIndex = -1;    // Index of the currently highlighted lyric line
        // --------------------------------------------------

        // --- UI Element References ---
        const loginSection = document.getElementById('login-section');
        const statusSection = document.getElementById('status-section');
        const statusMessage = document.getElementById('status-message');
        const songDisplay = document.getElementById('song-display');
        const songTitle = document.getElementById('song-title');
        const artistName = document.getElementById('artist-name');
        const albumName = document.getElementById('album-name');
        const albumArt = document.getElementById('album-art');
        const progressBar = document.getElementById('progress-bar');
        const pollingIndicator = document.getElementById('polling-indicator');
        const timeText = document.getElementById('time-text');
        const lyricsContent = document.getElementById('lyrics-content');

        // --- Utility Functions ---

        /** Generates a cryptographically secure random string. */
        function generateRandomString(length) {
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            const randomValues = crypto.getRandomValues(new Uint8Array(length));
            return randomValues.reduce((acc, x) => acc + possible[x % possible.length], "");
        }

        /** Base64-URL encodes a buffer. */
        function base64urlencode(buffer) {
            return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }

        /** Creates a SHA256 hash and converts it to a base64 URL-safe string. */
        async function sha256(plain) {
            const encoder = new TextEncoder();
            const data = encoder.encode(plain);
            const hash = await crypto.subtle.digest('SHA-256', data);
            return base64urlencode(hash);
        }
        
        /** Converts milliseconds to MM:SS format. */
        function msToTime(ms) {
            if (ms === null || isNaN(ms) || ms < 0) return '0:00';
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        /** * Cleans up track titles by removing common metadata in parentheses or brackets 
         * to improve matching accuracy with LRC APIs. 
         */
        function cleanTrackTitle(title) {
            // 1. Remove text in parentheses (e.g., (Live), (Remix))
            let cleaned = title.replace(/\s*\(.*?\)\s*/g, ' ');
            // 2. Remove text in brackets (e.g., [Explicit], [Official Video])
            cleaned = cleaned.replace(/\s*\[.*?\]\s*/g, ' ');
            // 3. Remove common features/mixes (e.g., "feat. Artist", " - Radio Edit")
            cleaned = cleaned.replace(/\s(feat|ft)\..*/i, '').replace(/\s-\s(Radio|Album|Single|Original)\s(Edit|Mix|Version).*/i, '').trim();
            // 4. Clean up multiple spaces left over
            return cleaned.replace(/\s+/g, ' ').trim();
        }
        
        /** * Parses LRC content into a structured array of lyric lines with time in milliseconds.
         * LRC format: [mm:ss.xx] Lyric text
         */
        function parseLrc(lrcContent) {
            const lines = [];
            const lrcRegex = /^\[(\d{2}):(\d{2})\.(\d{2,3})\](.*)/;

            lrcContent.split('\n').forEach(line => {
                const match = line.match(lrcRegex);
                if (match) {
                    const minutes = parseInt(match[1], 10);
                    const seconds = parseInt(match[2], 10);
                    // Milliseconds can be 2 or 3 digits. Normalize to 3.
                    let ms = parseInt(match[3].padEnd(3, '0'), 10);
                    const text = match[4].trim() || ' ';

                    const timeMs = (minutes * 60 * 1000) + (seconds * 1000) + ms;
                    
                    lines.push({ time: timeMs + 1000, text: text });
                }
            });
            
            // Sort by time just in case
            lines.sort((a, b) => a.time - b.time);
            
            return lines;
        }


        // --- Lyrics Management (LRC Lib Integration) ---
        
        /** Fetches synchronized lyrics from LRC Lib. */
        async function fetchSyncedLyrics(trackName, artistName) {
            // Display a loading message immediately
            lyricsContent.innerHTML = '<p class="text-gray-400 italic mt-4 text-center">Fetching synchronized lyrics...</p>';
            
            // Clean the track name for better API matching
            const cleanedTrackName = cleanTrackTitle(trackName);
            
            // Log the clean query parameters for debugging
            console.log(`LRC Lib Querying with: Track="${cleanedTrackName}", Artist="${artistName}"`);

            const url = `${LRCLIB_API_BASE}?track_name=${encodeURIComponent(cleanedTrackName)}&artist_name=${encodeURIComponent(artistName)}&album_name=&limit=1`;

            try {
                const response = await fetch(url);
                // console.log(response)
                
                if (!response.ok) {
                    console.error(`LRC Lib API failed: ${response.status}`);
                    return null;
                }
                
                const results = await response.json();
                console.log(results)
                
                if (results.length > 0 && results[0].plainLyrics && results[0].syncedLyrics) {
                    console.log(`LRC Lib Success: Found synced lyrics for "${trackName}"`);
                    // Success: Found synced LRC content
                    return parseLrc(results[0].syncedLyrics);
                }
                
                console.log(`LRC Lib Failure: No synced result found for "${trackName}"`);

                // Failure: No synchronized lyrics found
                return null;
                
            } catch (error) {
                console.error("Error fetching lyrics from LRC Lib:", error);
                return null;
            }
        }


        /** Renders the lyrics lines to the container, or shows a "not available" message. */
        function renderLyrics(lyrics, trackName, artistName) {
            activeLyricIndex = -1; // Reset lyric state
            
            if (lyrics && lyrics.length > 0) {
                // Render Synced Lyrics
                lyricsContent.innerHTML = '';
                lyrics.forEach((line, index) => {
                    const p = document.createElement('p');
                    p.textContent = line.text || ' '; // Use a space for empty lines
                    p.className = 'lyric-line transition-all duration-300';
                    p.dataset.time = line.time; // Store the start time
                    p.id = `lyric-line-${index}`;
                    lyricsContent.appendChild(p);
                });
            } else {
                // Show "Not Available" message
                lyricsContent.innerHTML = `
                    <p class="text-gray-400 italic mb-4 mt-8 text-base">
                        No synchronized lyrics found on LRC Lib for:
                        <br><span class="font-semibold text-white">"${trackName}" by ${artistName}</span>
                    </p>
                    <p class="text-gray-500 text-xs mt-2">
                        (LRC Lib is a community-sourced database, so coverage varies.)
                    </p>
                `;
            }
        }
        
        /** Finds and highlights the current lyric line based on progressMs. */
        function updateLyricHighlight(progressMs) {
            if (!currentLyrics) return;

            const lines = currentLyrics;
            let newIndex = -1;

            // Find the index of the line whose time is less than or equal to the current progress
            for (let i = lines.length - 1; i >= 0; i--) {
                if (progressMs >= lines[i].time) {
                    newIndex = i;
                    break;
                }
            }
            
            if (newIndex !== activeLyricIndex) {
                // Deactivate the old line
                if (activeLyricIndex !== -1) {
                    const oldLine = document.getElementById(`lyric-line-${activeLyricIndex}`);
                    if (oldLine) oldLine.classList.remove('active');
                }

                // Activate the new line
                if (newIndex !== -1) {
                    const newLine = document.getElementById(`lyric-line-${newIndex}`);
                    if (newLine) {
                        newLine.classList.add('active');
                        // Scroll the new line into view, centered if possible (after a short delay to account for size change)
                        setTimeout(() => {
                            newLine.scrollIntoView({
                                behavior: 'smooth',
                                block: 'center'
                            });
                        }, 50); 
                    }
                }
                activeLyricIndex = newIndex;
            }
        }


        // --- Authentication Flow (Omitted for brevity, kept in file) ---

        function redirectToAuthCodeFlow() {
            if (CLIENT_ID === 'PASTE_YOUR_CLIENT_ID_HERE') {
                console.error('ERROR: Please update CLIENT_ID in the script.');
                document.getElementById('status-message').textContent = 'AUTH ERROR: Please replace the placeholder ID in the script and reload.';
                document.getElementById('status-message').classList.remove('hidden');
                loginSection.classList.add('hidden');
                return;
            }

            const codeVerifier = generateRandomString(128);
            localStorage.setItem('code_verifier', codeVerifier);
            console.log("Requested Spotify Scope:", SCOPE);

            sha256(codeVerifier).then(codeChallenge => {
                const params = new URLSearchParams({
                    response_type: 'code',
                    client_id: CLIENT_ID,
                    scope: SCOPE,
                    code_challenge_method: 'S256',
                    code_challenge: codeChallenge,
                    redirect_uri: REDIRECT_URI,
                });

                window.location.href = `${AUTHORIZE_URL}?${params.toString()}`;
            }).catch(e => {
                console.error("Error generating code challenge:", e);
            });
        }

        async function getAccessToken(code) {
            const codeVerifier = localStorage.getItem('code_verifier');
            if (!codeVerifier) {
                console.error("Code verifier not found.");
                return null;
            }
            
            localStorage.removeItem('code_verifier'); 

            const params = new URLSearchParams({
                client_id: CLIENT_ID,
                grant_type: 'authorization_code',
                code: code,
                redirect_uri: REDIRECT_URI,
                code_verifier: codeVerifier,
            });

            try {
                const response = await fetch(TOKEN_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: params.toString(),
                });

                if (!response.ok) {
                    throw new Error(`Token request failed with status: ${response.status}`);
                }

                const data = await response.json();
                
                return data.access_token;
            } catch (error) {
                console.error('Error fetching access token:', error);
                return null;
            }
        }


        // --- Spotify API Interaction ---

        /** Fetches the currently playing song from Spotify. */
        async function fetchCurrentlyPlaying() {
            try {
                const response = await fetch(NOW_PLAYING_URL, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                if (response.status === 204) {
                    return null;
                }

                if (!response.ok) {
                    const errorDetails = await response.text().catch(() => response.statusText);
                    
                    if (response.status === 401) {
                        console.error("Access Token expired or invalid. Attempting re-login.");
                        setTimeout(() => {
                           window.location.href = REDIRECT_URI;
                        }, 100);
                        return null;
                    } 
                    
                    if (response.status === 403) {
                         console.error(`API Error 403 (Forbidden): The token is valid but lacks permission. Details: ${errorDetails}`);
                         statusMessage.textContent = `403 FORBIDDEN: Please ensure the Spotify account you logged in with is added as a 'User' in your app's 'Users and Access' settings in the Spotify Developer Dashboard.`;
                         throw new Error(`API Error 403 Forbidden: Missing scope or account whitelisting issue.`);
                    }

                    throw new Error(`API Error: ${response.status} ${response.statusText}`);
                }

                return await response.json();

            } catch (error) {
                console.error('Error fetching currently playing track:', error);
                if (!error.message.includes('403')) {
                    clearInterval(pollingIntervalId);
                    pollingIndicator.classList.add('hidden');
                    statusMessage.textContent = 'A critical network or API error occurred. Check console.';
                }
                return null;
            }
        }
        
        /**
         * Runs every 500ms to smoothly update the progress bar, time, and lyrics.
         */
        function smoothUpdateProgress() {
            const elapsedTime = Date.now() - progressStartTime;
            let currentProgressMs = initialProgressMs + elapsedTime;

            // Cap the progress at the track duration
            if (currentProgressMs > trackDurationMs) {
                currentProgressMs = trackDurationMs;
                clearInterval(progressUpdaterId);
                progressUpdaterId = null;
            }

            const progressPercent = (currentProgressMs / trackDurationMs) * 100;
            
            // Update UI
            progressBar.style.width = `${progressPercent}%`;
            timeText.textContent = `${msToTime(currentProgressMs)} / ${msToTime(trackDurationMs)}`;

            // Update Lyrics if they are loaded
            if (currentLyrics) {
                updateLyricHighlight(currentProgressMs);
            }
        }


        /** Main logic to poll for the currently playing song every 5 seconds. */
        function pollForSong() {
            loginSection.classList.add('hidden');
            statusSection.classList.remove('hidden');
            pollingIndicator.classList.remove('hidden');
            
            if (!statusMessage.textContent.includes('FORBIDDEN')) {
                 statusMessage.textContent = 'Waiting for you to start playing music...';
            }


            pollingIntervalId = setInterval(async () => {
                const data = await fetchCurrentlyPlaying();
                
                if (data && data.is_playing) {
                    // --- Case 1: Song is actively playing ---
                    const track = data.item;
                    const artistText = track.artists.map(a => a.name).join(', ');

                    if (track.id !== currentTrackId) {
                        
                        console.log('New track detected or resumed. Starting smooth update and lyric fetch.');
                        
                        // Stop old smooth interval
                        if (progressUpdaterId) clearInterval(progressUpdaterId);

                        // --- NEW LYRICS FETCH/LOAD ---
                        const trackName = track.name;
                        
                        // 1. Fetch lyrics from LRC Lib
                        currentLyrics = await fetchSyncedLyrics(trackName, artistText);
                        
                        // 2. Render lyrics or the "not available" message
                        renderLyrics(currentLyrics, trackName, artistText);
                        // ------------------------------------------
                        
                        // Update Metadata
                        songTitle.textContent = trackName;
                        artistName.textContent = artistText;
                        albumName.textContent = track.album.name;
                        albumArt.src = track.album.images[0]?.url || 'https://placehold.co/400x400/1DB954/ffffff?text=No+Art';
                        
                        // Initialize smooth update variables
                        currentTrackId = track.id;
                        initialProgressMs = data.progress_ms;
                        trackDurationMs = track.duration_ms;
                        progressStartTime = Date.now();
                        
                        // Start the smooth update interval (runs every 500ms)
                        progressUpdaterId = setInterval(smoothUpdateProgress, 250);

                        // Initial manual update to ensure immediate display
                        smoothUpdateProgress();
                        
                        // Update UI visibility
                        statusMessage.textContent = 'Currently Playing:';
                        statusMessage.classList.remove('hidden');
                        songDisplay.classList.remove('hidden');
                        pollingIndicator.classList.add('hidden');
                        
                    } else if (track.id === currentTrackId) {
                        // B. Same track is playing: Check for seeking (progress jump)
                        
                        const expectedProgressMs = initialProgressMs + (Date.now() - progressStartTime);
                        const reportedProgressMs = data.progress_ms;
                        const diff = Math.abs(expectedProgressMs - reportedProgressMs);
                        
                        // Re-sync if the reported position is off by more than 2 seconds (user seeked)
                        if (diff > 2000) {
                            console.log('Seek detected! Re-syncing progress.');
                            initialProgressMs = reportedProgressMs;
                            progressStartTime = Date.now();
                        }
                    }

                } else {
                    // --- Case 2: Nothing playing or music is paused (204 or is_playing=false) ---
                    
                    // Stop the smooth progress interval and clear lyrics
                    if (progressUpdaterId) {
                        clearInterval(progressUpdaterId);
                        progressUpdaterId = null;
                    }
                    currentTrackId = null;
                    currentLyrics = null;
                    lyricsContent.innerHTML = ''; // Clear the lyric area

                    
                    // Check if music is paused
                    if (data && !data.is_playing && data.item) {
                        const artistText = data.item.artists.map(a => a.name).join(', ');
                        statusMessage.textContent = `Music is paused: ${data.item.name} by ${artistText}`;
                        songDisplay.classList.add('hidden');
                    } else if (!statusMessage.textContent.includes('FORBIDDEN')) {
                        // Or no playback found (204)
                        statusMessage.textContent = 'Waiting for you to start playing music...';
                        songDisplay.classList.add('hidden');
                    }
                    
                    statusMessage.classList.remove('hidden');
                    pollingIndicator.classList.remove('hidden');
                }

            }, 5000); // Main state check every 5 seconds
        }

        // --- Main Initialization ---

        async function init() {
            const params = new URLSearchParams(window.location.search);
            const code = params.get('code');

            if (pollingIntervalId) clearInterval(pollingIntervalId);
            if (progressUpdaterId) clearInterval(progressUpdaterId);

            if (code) {
                statusSection.classList.remove('hidden');
                statusMessage.textContent = 'Authenticating...';
                loginSection.classList.add('hidden');

                history.replaceState(null, '', REDIRECT_URI); 

                accessToken = await getAccessToken(code);
                
                if (accessToken) {
                    console.log("Successfully retrieved access token. Starting playback poll.");
                    pollForSong();
                } else {
                    statusMessage.textContent = 'Authentication failed (Token exchange error). Check console.';
                    loginSection.classList.remove('hidden');
                }

            } else {
                loginSection.classList.remove('hidden');
                document.getElementById('login-button').addEventListener('click', redirectToAuthCodeFlow);
            }
        }

        // Run the main function on page load
        init();
    </script>
</body>
</html>